// Optimized Expansion rectangle cover in Oaf.
// This mirrors the greedy "find best rectangle, mark/remove, repeat" strategy.
//
// Grid storage note:
// Each row is stored as a bitmask in an int array.
// Bit i (LSB = col 0) indicates whether cell(row, i) is still available (1) or consumed (0).

struct Rect [int row, int col, int height, int width, int area, int mask];

rows = 4;
cols = 5;
all_mask = (1 << cols) - 1;

// Sample 4x5 grid rows:
// [1 1 1 0 0]
// [1 1 1 1 0]
// [1 1 0 0 1]
// [0 1 1 1 1]
flux [int] row_masks = [0b00111, 0b01111, 0b10011, 0b11110];
flux [[int]] result = [
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0]
];

flux rect_id = 1;
flux total_area = 0;

loop true => {
    // Recompute best rectangle for current working grid.
    flux best = Rect[0, 0, 0, 0, 0, 0];

    flux top = 0;
    loop top < rows => {
        flux running = row_masks[top];

        flux bottom = top;
        loop bottom < rows => {
            flux row_mask = row_masks[bottom];

            running = running & row_mask;
            if running == 0 => {
                break;
            }

            // Longest contiguous run of 1-bits in the current intersection mask.
            flux scan_col = 0;
            flux current_run = 0;
            flux current_start = 0;
            flux local_best_width = 0;
            flux local_best_start = 0;

            loop scan_col < cols => {
                flux bit = (running >> scan_col) & 1;
                if bit == 1 => {
                    if current_run == 0 => current_start = scan_col;
                    current_run += 1;
                    if current_run > local_best_width => {
                        local_best_width = current_run;
                        local_best_start = current_start;
                    }
                } -> {
                    current_run = 0;
                }

                scan_col += 1;
            }

            if local_best_width > 0 => {
                flux height = bottom - top + 1;
                flux area = height * local_best_width;
                flux local_mask = ((1 << local_best_width) - 1) << local_best_start;

                if area > best.area => {
                    best = Rect[top, local_best_start, height, local_best_width, area, local_mask];
                }
            }

            bottom += 1;
        }

        top += 1;
    }

    if best.area == 0 => {
        break;
    }

    // Mark/remove selected rectangle from working grid.
    flux clear_mask = all_mask & (~best.mask);
    flux mark_r = best.row;
    flux end_row = best.row + best.height;
    flux end_col = best.col + best.width;
    loop mark_r < end_row => {
        flux mark_c = best.col;
        loop mark_c < end_col => {
            result[mark_r][mark_c] = rect_id;
            mark_c += 1;
        }

        row_masks[mark_r] = row_masks[mark_r] & clear_mask;
        mark_r += 1;
    }

    total_area += best.area;
    rect_id += 1;
}

// Returns the total area covered by all greedy-selected rectangles.
Jot("Final rectangle-id grid:");
Jot("" + result[0][0] + " " + result[0][1] + " " + result[0][2] + " " + result[0][3] + " " + result[0][4]);
Jot("" + result[1][0] + " " + result[1][1] + " " + result[1][2] + " " + result[1][3] + " " + result[1][4]);
Jot("" + result[2][0] + " " + result[2][1] + " " + result[2][2] + " " + result[2][3] + " " + result[2][4]);
Jot("" + result[3][0] + " " + result[3][1] + " " + result[3][2] + " " + result[3][3] + " " + result[3][4]);
Jot("Total covered area:");
Jot(total_area);
return total_area;
